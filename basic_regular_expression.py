
"""
이 파일은 클렌징 처리를 할 때 도움이 되는 정규 표현식에 대한 코드이다.

정규 표현식(정규식)이란 프로그래밍에서 문자열을 다룰 때 문자열의 일정한 패턴을 표현하는 일종의 형식 언어이다.
regular expression을 줄여서 일반적으로 regex라 표현한다.

정규 표현식은 파이썬의 고유 문법이 아니라, 문자열을 처리하는 모든 프로그래밍에서 사용되는 공통 문법이다.
"""

"""
대괄호는 문자 클래스로써 대괄호 안에 포함된 문자들 중 하나와의 매치를 뜻함.

'apple','blueberry','coconut'이 정규표현식이 [ae]와 매치 여부를 보자.
'apple'에는 정규식 내의 a와 e가 모두 존재하므로 매치가 된다.
'blueberry'에는 e가 존재하므로 매치됨. 'coconut'은 어느 문자도 포함하지 않으므로 매치가 안됨.

[]안에 하이픈(-)을 입력하면 두 문자 사이의 범위를 의미한다.
[a-e]라는 정규식은 [abcde]와 동일하며, [0-5]는 [012345]와 동일하다.
그외로는 [a-z]는 소문자, [A-Z]는 대문자, [a-zA-Z]는 모든 알파벳, [0-9]는 모든 숫자를 뜻한다.

[]안에 ^는 반대를 뜻한다.
[^0-9]는 숫자를 제외한 문자만 매치를, [^abc]는 abc를 제외한 모든 문자와 매치를 뜻한다.


자주 사용하는 문자 클래스의 경우는 별도의 표기법이 존재한다.

\d는 숫자와 매치, [0-9]와 동일.
\D는 숫자가 아닌 것과 매치, [^0-9]와 동일.
\s는 whitespace(공백) 문자와 매치, [\t\n\r\f\v]와 동일.
\S는 whitespace 문자가 아닌 것과 매치, [^\t\n\r\f\v]와 동일.
\w 문자+숫자와 매치, [a-zA-Z0-9]와 동일.
\W 문자+숫자가 아닌 문자와 매치 [^a-zA-Z0-9]와 동일.

대문자로 표현된 문자 클래스는 소문자의 반대로 보면 된다.


Dot(.)은 줄바꿈 문자인 \n을 제외한 모든 문자와 매치되며, Dot 하나당 임의의 한 문자를 나타낸다.
정규식 a.e는 'a+모든문자+e'의 형태로써, a와 e 문자 사이에는 어떤 문자가 들어가도 모두 매치가 된다.

반복을 의미하는 메타문자로는:
*은 * 바로 앞에 있는 문자가 0부터 무한대로 반복될 수 있다는 의미이다.
ca*t라는 정규식은 a가 0부터 무한대로 반복되기 때문에,
'ct', 'cat', 'caaaaat' 모두 정규식과 매치가 된다. 그리고 +는 최소 1번 이상 반복될 때 사용된다.

{}를 사용하면 반복 횟수를 고정할 수 있다.
{m, n}은 반복 횟수가 m부터 n까지 고정된다. m 혹은 n은 생략할 수도 있다.
{3,}의 경우 반복 횟수가 3이상, {0, 3}의 경우 반복 횟수가 3 이하를 의마하게 된다.

메타문자 ?는 {0,1}과 동일하며, ? 앞에 문자가 있어도 되고 없어도 된다는 의미이다.


| (수직선)은 or과 동일한 의미이다. expr1 | expr2는 둘 중 하나의 형태만 만족해도 매치가 된다는 뜻이다.
^는 문자열의 맨 처음과 일치함을 의미한다. ^a 정규식은 a로 시작하는 단어와 매치된다.
$는 ^와 반대의 의미로, 문자열의 끝과 매치함을 의미한다. a$는 a로 끝나는 단어와 매치된다.

\는 메타문자의 성질을 없앨 때 붙인다. ^나 $문자를 메타문자가 아닌 문자 그 자체로 매치하고 싶을 때, \^, \$로 사용된다.

()는 괄호안의 문자열의 하나로 묶어서 취급한다.
"""

import re
"""
정규 표현식과 관련된 메서드는:
    match(): 시작부분부터 일치하는 패턴을 찾는다.
    search(): 첫 번째로 일치하는 패턴을 찾는다.
    findall(): 일치하는 모든 패턴을 찾는다.
    finditer(): findall()에서 반복 가능한 객체를 반환한다.
"""


#29.2%만 추출.
data = '동 기업의 매출액은 전년 대비 29.2% 늘어났습니다.'
re.findall('\d+.\d+%', data) #\d는 숫자를 의미. 즉, 숫자.숫자% 로 사용했음.
re.findall(r'\d+\.\d+%', data) #raw string r''로, escape 문제 방지를 위해 사실상 이 형태로 사용된다.



#re.compile()을 통해서 정규 표현식을 컴파일하여 변수에 저장한 후에 사용할 수 있다.
p = re.compile('[a-z]+')
type(p)   #출력되는 re.Pattern은 컴파일된 정규 표현식 형태를 의미한다.

m = p.match('python')
m
m.group()

#둘을 서로 비교해보자.
print(p.match('use python'))
print(p.match('Use python'))


#[가-힣]+ 은 모든 한글을 뜻한다.
p = re.compile('[가-힣]+')
m = p.match('파이썬')
m

#se만 매치되는 것을 볼 수 있다. 띄어쓰기는 알파벳이 아니므로 매치가 안되는 것을 알 수 있다.
p = re.compile('[a-z]+')
m = p.search('Use python')
print(m)

#findall
p = re.compile('[a-zA-Z]+')
m = p.findall('Life is too short, You need Python.')
print(m)


#callable_iterator object=반복 가능한 객체를 반환하는 것을 볼 수 있다.
p = re.compile('[a-zA-Z]+')
m = p.finditer('Life is too short, You need Python.')
print(m)
#for문으로 출력 가능하다.
for i in m:
    print(i)
    
    
#로또 번호 추출
num = """r\n\t\t\t\t\t\r\n\t\t\t\t\t\t\t15\r\n\t\t\t\t\t\t23\r\n\t\t\t\t\t\t29\r\n\t\t\t\t\t\t34\r\n\t\t\t\t\t\t40\r\n\t\t\t\t\t\t44\r\n\t\t\t\t\r\t\t\t\t"""
p = re.compile('[0-9]+')
m = p.findall(num)
print(m)
    

#날짜만 추출
dt = '> 오늘의 날짜는 2022.12.31 입니다.'
p = re.compile('[0-9]+.[0-9]+.[0-9]+')
p.findall(dt)
#간략화
re.findall(r'(\d{4})\.(\d{2})\.(\d{2})', dt)
#join으로도 가능
p = re.compile('[0-9]+')
m = p.findall(dt)
print(m)
''.join(m)



#어차피 크롤링한 결과물에서 원하는 것들만 한 번에 정규식을 이용해 추출하는 것은 상급자들한테 쉬운 일이 아니다.
#그렇기 때문에 HTML 구조 파싱은 BeautifulSoup으로 하고, 정규식은 텍스트 클렌징 보조 용도로만 사용된다.

# https://regex101.com/ 같은 사이트를 이용해서 연습 혹은 테스트를 할 수 있다.
















